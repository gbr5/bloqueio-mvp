// Bloqueio Game - Prisma Schema
// Phase 2: Adding Better Auth models for user authentication

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// BETTER AUTH MODELS (User Authentication)
// ============================================

// User account (Better Auth core model)
model User {
  id            String   @id @default(cuid())
  name          String
  email         String   @unique
  emailVerified Boolean  @default(false)
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  sessions Session[]
  accounts Account[]

  // Custom fields for game stats
  gamesPlayed Int @default(0)
  gamesWon    Int @default(0)

  @@index([email])
}

// Session (Better Auth core model)
model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([token])
}

// Account (Better Auth core model - for OAuth providers)
model Account {
  id                    String    @id @default(cuid())
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accountId             String // Provider's user ID
  providerId            String // "github", "google", etc.
  accessToken           String?
  refreshToken          String?
  idToken               String? // ID token from OAuth provider (Google, etc.)
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String? // For email/password auth
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@unique([providerId, accountId])
  @@index([userId])
}

// Verification (Better Auth core model - for email verification)
model Verification {
  id         String   @id @default(cuid())
  identifier String // Email or phone
  value      String // Verification code
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([identifier, value])
}

// ============================================
// GAME MODELS
// ============================================

// Room represents a game session
model Room {
  id            String     @id @default(cuid())
  code          String     @unique // 6-character code (R7IAG2)
  status        RoomStatus @default(WAITING)
  gameMode      GameMode   @default(FOUR_PLAYER) // 2P or 4P mode
  hostSessionId String? // Session ID of player who created the room (clear naming)
  currentTurn   Int        @default(0) // Current player ID (0-3)
  winner        Int? // Winning player ID

  // Bot system fields
  allowBots  Boolean @default(false) // Can this room have bot players?
  turnNumber Int     @default(0) // Increments each turn (for idempotency)
  botSeed    String? // Deterministic RNG seed for bot reproducibility

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  players  Player[]
  barriers Barrier[]
  moves    Move[] // Move history for undo
  botJobs  BotMoveJob[]
  botLogs  BotDecisionLog[]

  @@index([code])
  @@index([status])
  @@index([gameMode])
}

enum RoomStatus {
  WAITING // Lobby - players joining
  PLAYING // Game in progress
  FINISHED // Game over
}

enum GameMode {
  TWO_PLAYER // 2 players, 12 barriers each
  FOUR_PLAYER // 4 players, 6 barriers each
}

// Player in a specific room
model Player {
  id     String @id @default(cuid())
  roomId String
  room   Room   @relation(fields: [roomId], references: [id], onDelete: Cascade)

  // Identity - can be linked to User account OR use sessionId for guests
  userId    String? // Optional link to Better Auth User (null for guest players)
  sessionId String? // Server-generated session ID (null for bot players)

  playerId Int // 0-3 (position in game)
  name     String // User's name, "Guest Player X", or "Bot (Easy)"
  color    String // "#ef4444", "#3b82f6", etc.

  // Bot configuration (NO isBot field - derive from playerType)
  playerType PlayerType @default(HUMAN) // HUMAN | BOT_EASY | BOT_MEDIUM | BOT_HARD

  // Game position - CORRECTED starting positions (first cell AFTER border)
  row       Int // Current row position
  col       Int // Current column position
  wallsLeft Int      @default(6)
  goalSide  GoalSide

  joinedAt   DateTime @default(now())
  lastActive DateTime @updatedAt

  @@unique([roomId, sessionId]) // One player per session per room (null-safe for bots)
  @@unique([roomId, playerId]) // Each slot 0-3 is unique per room
  @@unique([roomId, userId]) // Each user can only join once per room (if logged in)
  @@index([sessionId])
  @@index([userId])
  @@index([playerType])
}

enum GoalSide {
  TOP
  RIGHT
  BOTTOM
  LEFT
}

// ============================================
// BOT SYSTEM MODELS
// ============================================

enum PlayerType {
  HUMAN
  BOT_EASY
  BOT_MEDIUM
  BOT_HARD
}

enum BotJobStatus {
  PENDING // Waiting to be processed
  RUNNING // Currently executing
  COMPLETED // Successfully completed
  STALE // turnNumber mismatch (skip)
  FAILED // Error during execution
}

// Barrier placed on the board
model Barrier {
  id          String             @id @default(cuid())
  roomId      String
  room        Room               @relation(fields: [roomId], references: [id], onDelete: Cascade)
  row         Int // Base row (top-left of 2x2 area)
  col         Int // Base column
  orientation BarrierOrientation
  placedBy    Int // Player ID who placed it
  createdAt   DateTime           @default(now())

  @@index([roomId])
}

enum BarrierOrientation {
  HORIZONTAL
  VERTICAL
}

// Move history (for undo feature)
model Move {
  id        String   @id @default(cuid())
  roomId    String
  room      Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  playerId  Int // Player who made the move
  fromRow   Int
  fromCol   Int
  toRow     Int
  toCol     Int
  createdAt DateTime @default(now())

  @@index([roomId])
  @@index([createdAt])
}

// ============================================
// BOT SYSTEM TABLES
// ============================================

// Server-driven bot move job queue
model BotMoveJob {
  id           String       @id @default(cuid())
  code         String // Room code (not roomId for consistency)
  room         Room         @relation(fields: [code], references: [code], onDelete: Cascade)
  playerId     Int // Bot player ID (0-3)
  expectedTurn Int // Idempotency: skip if room.turnNumber != this
  status       BotJobStatus @default(PENDING)
  createdAt    DateTime     @default(now())
  startedAt    DateTime?
  completedAt  DateTime?
  error        String?

  @@unique([code, playerId, expectedTurn]) // Prevent duplicate jobs
  @@index([code, status])
  @@index([createdAt])
}

// Separate logging table (prevents Room row bloat)
model BotDecisionLog {
  id                  String   @id @default(cuid())
  code                String // Room code
  room                Room     @relation(fields: [code], references: [code], onDelete: Cascade)
  playerId            Int // Bot player ID
  turnNumber          Int // Which turn this decision was made
  difficulty          String // EASY | MEDIUM | HARD
  moveType            String // MOVE | WALL
  decision            Json // Move details or wall placement
  reasoning           Json? // For Hard bot: minimax scores, pruning stats
  computeTimeMs       Int // Time spent computing (for profiling)
  candidatesEvaluated Int // How many moves/walls evaluated
  createdAt           DateTime @default(now())

  @@index([code, createdAt])
  @@index([difficulty, createdAt])
}
